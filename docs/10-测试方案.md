# 测试方案文档

## 测试策略

### 测试金字塔

```
        ┌──────────────┐
        │  E2E 测试    │  10%
        │  (少量)      │
        └──────────────┘
       ┌────────────────┐
       │  集成测试      │  30%
       │  (适量)        │
       └────────────────┘
      ┌──────────────────┐
      │  单元测试        │  60%
      │  (大量)          │
      └──────────────────┘
```

### 测试类型

| 测试类型 | 占比 | 工具 | 执行频率 |
|----------|------|------|----------|
| 单元测试 | 60% | Google Test | 每次提交 |
| 集成测试 | 30% | Google Test | 每次提交 |
| E2E 测试 | 10% | 手动/自动化 | 每日/发版前 |
| 性能测试 | - | 自定义工具 | 每周/发版前 |
| 压力测试 | - | 自定义脚本 | 发版前 |

## C++ 单元测试

### Google Test 配置

#### CMakeLists.txt

```cmake
# 启用测试
enable_testing()

# 查找 Google Test
find_package(GTest CONFIG REQUIRED)

# 测试可执行文件
file(GLOB_RECURSE TEST_SOURCES "tests/*.cpp")
add_executable(CodeCanvasTests ${TEST_SOURCES})

target_link_libraries(CodeCanvasTests PRIVATE
  GTest::gtest
  GTest::gtest_main
  GTest::gmock
  # 链接被测试的库
  CodeCanvasLib
)

# 添加测试
include(GoogleTest)
gtest_discover_tests(CodeCanvasTests)
```

#### 安装 Google Test

```powershell
# 使用 vcpkg
vcpkg install gtest:x64-windows
```

### 测试用例示例

#### DockManager 测试

```cpp
// tests/modules/DockManagerTests.cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "modules/dock/DockManager.h"

class DockManagerTest : public ::testing::Test {
protected:
  void SetUp() override {
    // 创建测试用的 DockManager
    m_windowMgr = std::make_unique<MockWindowManager>();
    m_renderEngine = std::make_unique<MockRenderEngine>();
    m_dockManager = std::make_unique<DockManager>(*m_windowMgr, *m_renderEngine);
    
    // 初始化
    m_dockManager->Initialize();
  }
  
  void TearDown() override {
    m_dockManager->Shutdown();
  }
  
  std::unique_ptr<MockWindowManager> m_windowMgr;
  std::unique_ptr<MockRenderEngine> m_renderEngine;
  std::unique_ptr<DockManager> m_dockManager;
};

TEST_F(DockManagerTest, AddApp) {
  // Arrange
  std::string appPath = "C:\\Windows\\notepad.exe";
  
  // Act
  std::string id = m_dockManager->AddApp(appPath);
  
  // Assert
  ASSERT_FALSE(id.empty());
  auto apps = m_dockManager->GetApps();
  ASSERT_EQ(apps.size(), 1);
  EXPECT_EQ(apps[0]["path"], appPath);
}

TEST_F(DockManagerTest, RemoveApp) {
  // Arrange
  std::string id = m_dockManager->AddApp("C:\\Windows\\notepad.exe");
  
  // Act
  bool success = m_dockManager->RemoveApp(id);
  
  // Assert
  ASSERT_TRUE(success);
  auto apps = m_dockManager->GetApps();
  EXPECT_EQ(apps.size(), 0);
}

TEST_F(DockManagerTest, RemoveNonExistentApp) {
  // Act & Assert
  EXPECT_FALSE(m_dockManager->RemoveApp("non-existent-id"));
}

TEST_F(DockManagerTest, UpdatePosition) {
  // Arrange
  std::string id1 = m_dockManager->AddApp("C:\\app1.exe");
  std::string id2 = m_dockManager->AddApp("C:\\app2.exe");
  
  // Act
  m_dockManager->MoveApp(id2, 0);
  
  // Assert
  auto apps = m_dockManager->GetApps();
  EXPECT_EQ(apps[0]["id"], id2);
  EXPECT_EQ(apps[1]["id"], id1);
}
```

#### ConfigManager 测试

```cpp
// tests/core/ConfigManagerTests.cpp
#include <gtest/gtest.h>
#include "core/ConfigManager.h"
#include <filesystem>

class ConfigManagerTest : public ::testing::Test {
protected:
  void SetUp() override {
    m_testConfigPath = std::filesystem::temp_directory_path() / "test_config.json";
    ConfigManager::Instance().Load(m_testConfigPath.string());
  }
  
  void TearDown() override {
    std::filesystem::remove(m_testConfigPath);
  }
  
  std::filesystem::path m_testConfigPath;
};

TEST_F(ConfigManagerTest, GetDefaultValue) {
  int iconSize = ConfigManager::Instance().Get<int>("dock.iconSize", 48);
  EXPECT_EQ(iconSize, 48);
}

TEST_F(ConfigManagerTest, SetAndGet) {
  // Set
  ConfigManager::Instance().Set("dock.iconSize", 64);
  
  // Get
  int iconSize = ConfigManager::Instance().Get<int>("dock.iconSize");
  EXPECT_EQ(iconSize, 64);
}

TEST_F(ConfigManagerTest, SaveAndLoad) {
  // Set value
  ConfigManager::Instance().Set("test.value", 123);
  ConfigManager::Instance().Save();
  
  // Create new instance
  ConfigManager newConfig;
  newConfig.Load(m_testConfigPath.string());
  
  // Verify
  int value = newConfig.Get<int>("test.value");
  EXPECT_EQ(value, 123);
}

TEST_F(ConfigManagerTest, ChangeCallback) {
  bool callbackCalled = false;
  int newValue = 0;
  
  ConfigManager::Instance().OnChange("dock.iconSize", 
    [&](const std::string& key, const auto& value) {
      callbackCalled = true;
      newValue = value;
    });
  
  ConfigManager::Instance().Set("dock.iconSize", 72);
  
  EXPECT_TRUE(callbackCalled);
  EXPECT_EQ(newValue, 72);
}
```

#### Database 测试

```cpp
// tests/core/DatabaseTests.cpp
#include <gtest/gtest.h>
#include "core/Database.h"

class DatabaseTest : public ::testing::Test {
protected:
  void SetUp() override {
    m_dbPath = ":memory:";  // 内存数据库
    Database::Instance().Initialize(m_dbPath);
  }
  
  std::string m_dbPath;
};

TEST_F(DatabaseTest, CreateTable) {
  bool success = Database::Instance().Execute(R"(
    CREATE TABLE test (
      id INTEGER PRIMARY KEY,
      name TEXT NOT NULL
    )
  )");
  
  ASSERT_TRUE(success);
}

TEST_F(DatabaseTest, InsertAndQuery) {
  Database::Instance().Execute(R"(
    CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT)
  )");
  
  // Insert
  auto stmt = Database::Instance().Prepare(
    "INSERT INTO test (name) VALUES (?)"
  );
  stmt.Bind(1, "Test Item");
  ASSERT_TRUE(stmt.Step());
  
  // Query
  auto results = Database::Instance().Query("SELECT * FROM test");
  ASSERT_EQ(results.size(), 1);
  EXPECT_EQ(results[0]["name"], "Test Item");
}

TEST_F(DatabaseTest, Transaction) {
  Database::Instance().Execute(R"(
    CREATE TABLE test (id INTEGER PRIMARY KEY, value INTEGER)
  )");
  
  {
    auto tx = Database::Instance().BeginTransaction();
    
    Database::Instance().Execute("INSERT INTO test (value) VALUES (1)");
    Database::Instance().Execute("INSERT INTO test (value) VALUES (2)");
    
    tx.Commit();
  }
  
  auto results = Database::Instance().Query("SELECT COUNT(*) as count FROM test");
  EXPECT_EQ(results[0]["count"], 2);
}

TEST_F(DatabaseTest, TransactionRollback) {
  Database::Instance().Execute(R"(
    CREATE TABLE test (id INTEGER PRIMARY KEY, value INTEGER)
  )");
  
  {
    auto tx = Database::Instance().BeginTransaction();
    
    Database::Instance().Execute("INSERT INTO test (value) VALUES (1)");
    
    tx.Rollback();
    // tx 析构时不会提交
  }
  
  auto results = Database::Instance().Query("SELECT COUNT(*) as count FROM test");
  EXPECT_EQ(results[0]["count"], 0);
}
```

### Mock 对象

```cpp
// tests/mocks/MockWindowManager.h
#include <gmock/gmock.h>
#include "core/WindowManager.h"

class MockWindowManager : public WindowManager {
public:
  MOCK_METHOD(std::shared_ptr<BaseWindow>, CreateWindow, 
    (const WindowConfig& config), (override));
  
  MOCK_METHOD(void, DestroyWindow, (HWND hwnd), (override));
  
  MOCK_METHOD(BaseWindow*, GetWindow, (HWND hwnd), (override));
  
  MOCK_METHOD(std::vector<MonitorInfo>, GetMonitors, (), (override));
};

// 使用
TEST(Example, MockTest) {
  MockWindowManager mockWinMgr;
  
  EXPECT_CALL(mockWinMgr, CreateWindow(testing::_))
    .WillOnce(testing::Return(std::make_shared<MockWindow>()));
  
  // 测试代码...
}
```

## 前端测试

### Vitest 配置

#### 安装

```powershell
cd frontend
npm install -D vitest @vue/test-utils jsdom
```

#### vite.config.ts

```typescript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  test: {
    globals: true,
    environment: 'jsdom',
    coverage: {
      provider: 'c8',
      reporter: ['text', 'json', 'html']
    }
  }
})
```

### 组件测试

```typescript
// tests/components/Button.spec.ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import Button from '@/components/base/Button.vue'

describe('Button', () => {
  it('renders correctly', () => {
    const wrapper = mount(Button, {
      props: {
        text: 'Click Me'
      }
    })
    
    expect(wrapper.text()).toContain('Click Me')
  })
  
  it('emits click event', async () => {
    const wrapper = mount(Button)
    
    await wrapper.trigger('click')
    
    expect(wrapper.emitted()).toHaveProperty('click')
    expect(wrapper.emitted('click')).toHaveLength(1)
  })
  
  it('is disabled when prop is set', () => {
    const wrapper = mount(Button, {
      props: {
        disabled: true
      }
    })
    
    expect(wrapper.element).toBeDisabled()
    expect(wrapper.classes()).toContain('disabled')
  })
})
```

### Store 测试

```typescript
// tests/stores/dock.spec.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useDockStore } from '@/stores/dock'

describe('Dock Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })
  
  it('initializes with empty apps', () => {
    const store = useDockStore()
    expect(store.apps).toEqual([])
  })
  
  it('adds app', () => {
    const store = useDockStore()
    
    store.addApp({
      id: 'app-1',
      name: 'Test App',
      path: 'C:\\test.exe',
      position: 0
    })
    
    expect(store.apps).toHaveLength(1)
    expect(store.apps[0].name).toBe('Test App')
  })
  
  it('removes app', () => {
    const store = useDockStore()
    
    store.addApp({ id: 'app-1', name: 'Test', path: 'C:\\test.exe', position: 0 })
    store.removeApp('app-1')
    
    expect(store.apps).toHaveLength(0)
  })
})
```

### API 测试

```typescript
// tests/api/ipc.spec.ts
import { describe, it, expect, vi } from 'vitest'
import { ipc } from '@/lib/ipc'

// Mock WebView2
global.window.chrome = {
  webview: {
    postMessage: vi.fn(),
    addEventListener: vi.fn()
  }
}

describe('IPC Client', () => {
  it('calls method and resolves promise', async () => {
    const mockResponse = {
      jsonrpc: '2.0',
      result: { success: true },
      id: 1
    }
    
    // 模拟 WebView 响应
    setTimeout(() => {
      const event = new MessageEvent('message', {
        data: JSON.stringify(mockResponse)
      })
      window.chrome.webview.dispatchEvent(event)
    }, 10)
    
    const result = await ipc.call('test.method', {})
    
    expect(result).toEqual({ success: true })
  })
})
```

## 集成测试

### Dock 集成测试

```cpp
// tests/integration/DockIntegrationTests.cpp
#include <gtest/gtest.h>
#include "modules/dock/DockManager.h"
#include "core/Database.h"

class DockIntegrationTest : public ::testing::Test {
protected:
  void SetUp() override {
    // 使用真实的组件
    Database::Instance().Initialize(":memory:");
    m_windowMgr = std::make_unique<WindowManager>();
    m_renderEngine = std::make_unique<RenderEngine>();
    m_dockManager = std::make_unique<DockManager>(*m_windowMgr, *m_renderEngine);
    m_dockManager->Initialize();
  }
  
  std::unique_ptr<WindowManager> m_windowMgr;
  std::unique_ptr<RenderEngine> m_renderEngine;
  std::unique_ptr<DockManager> m_dockManager;
};

TEST_F(DockIntegrationTest, AddAppPersistsToDatabase) {
  // Add app
  std::string id = m_dockManager->AddApp("C:\\test.exe");
  
  // Verify in database
  auto results = Database::Instance().Query(
    "SELECT * FROM dock_apps WHERE id = '" + id + "'"
  );
  
  ASSERT_EQ(results.size(), 1);
  EXPECT_EQ(results[0]["path"], "C:\\test.exe");
}

TEST_F(DockIntegrationTest, LaunchAppCreatesProcess) {
  // Add and launch notepad
  std::string id = m_dockManager->AddApp("C:\\Windows\\notepad.exe");
  bool success = m_dockManager->LaunchApp(id);
  
  ASSERT_TRUE(success);
  
  // Wait for process to start
  std::this_thread::sleep_for(std::chrono::seconds(1));
  
  // Verify running
  m_dockManager->UpdateRunningApps();
  auto apps = m_dockManager->GetApps();
  
  // Find our app
  auto it = std::find_if(apps.begin(), apps.end(),
    [&id](const auto& app) { return app["id"] == id; });
  
  ASSERT_NE(it, apps.end());
  EXPECT_TRUE((*it)["isRunning"]);
  
  // Cleanup: kill notepad
  system("taskkill /F /IM notepad.exe");
}
```

## E2E 测试

### 手动测试用例

#### Dock 功能测试

**测试用例 TC-DOCK-001**：添加应用

| 步骤 | 操作 | 预期结果 |
|------|------|----------|
| 1 | 打开设置窗口 | 设置窗口显示 |
| 2 | 点击"Dock"标签 | 显示 Dock 设置页 |
| 3 | 点击"添加应用" | 显示文件选择对话框 |
| 4 | 选择 notepad.exe | 文件路径填充到输入框 |
| 5 | 点击"确定" | Dock 中显示新图标 |
| 6 | 检查数据库 | dock_apps 表中有新记录 |

**测试用例 TC-DOCK-002**：启动应用

| 步骤 | 操作 | 预期结果 |
|------|------|----------|
| 1 | 点击 Dock 中的应用图标 | 应用启动 |
| 2 | 观察图标 | 显示运行指示器 |
| 3 | 关闭应用 | 运行指示器消失 |

#### 壁纸功能测试

**测试用例 TC-WP-001**：设置静态壁纸

| 步骤 | 操作 | 预期结果 |
|------|------|----------|
| 1 | 打开壁纸库 | 显示所有壁纸 |
| 2 | 点击一张图片 | 显示预览 |
| 3 | 点击"应用" | 桌面壁纸立即切换 |
| 4 | 重启应用 | 壁纸保持不变 |

**测试用例 TC-WP-002**：播放视频壁纸

| 步骤 | 操作 | 预期结果 |
|------|------|----------|
| 1 | 选择视频壁纸 | - |
| 2 | 点击"应用" | 视频开始播放 |
| 3 | 检查性能 | GPU < 5%, CPU < 2% |
| 4 | 点击桌面图标 | 正常响应 |

### 自动化 E2E

```python
# tests/e2e/test_dock.py
import pyautogui
import time
import subprocess

def test_add_and_launch_app():
    # 启动应用
    app = subprocess.Popen(['CodeCanvas.exe'])
    time.sleep(2)
    
    try:
        # 打开设置（快捷键）
        pyautogui.hotkey('ctrl', ',')
        time.sleep(1)
        
        # 点击"添加应用"
        add_btn = pyautogui.locateOnScreen('add_button.png')
        pyautogui.click(add_btn)
        time.sleep(1)
        
        # 选择文件
        pyautogui.write('C:\\Windows\\notepad.exe')
        pyautogui.press('enter')
        time.sleep(1)
        
        # 确认
        ok_btn = pyautogui.locateOnScreen('ok_button.png')
        pyautogui.click(ok_btn)
        time.sleep(1)
        
        # 验证图标出现
        icon = pyautogui.locateOnScreen('notepad_icon.png')
        assert icon is not None, "图标未出现在 Dock 中"
        
        # 点击启动
        pyautogui.click(icon)
        time.sleep(2)
        
        # 验证 notepad 运行
        notepad_window = pyautogui.locateOnScreen('notepad_window.png')
        assert notepad_window is not None, "Notepad 未启动"
        
    finally:
        # 清理
        subprocess.run(['taskkill', '/F', '/IM', 'notepad.exe'])
        app.terminate()
```

## 性能测试

### 性能基准测试

```cpp
// tests/performance/BenchmarkTests.cpp
#include <benchmark/benchmark.h>
#include "modules/dock/DockManager.h"

static void BM_AddApp(benchmark::State& state) {
  DockManager dockMgr;
  dockMgr.Initialize();
  
  for (auto _ : state) {
    std::string id = dockMgr.AddApp("C:\\test.exe");
    benchmark::DoNotOptimize(id);
  }
  
  dockMgr.Shutdown();
}
BENCHMARK(BM_AddApp);

static void BM_GetApps(benchmark::State& state) {
  DockManager dockMgr;
  dockMgr.Initialize();
  
  // 预填充 100 个应用
  for (int i = 0; i < 100; ++i) {
    dockMgr.AddApp("C:\\app" + std::to_string(i) + ".exe");
  }
  
  for (auto _ : state) {
    auto apps = dockMgr.GetApps();
    benchmark::DoNotOptimize(apps);
  }
  
  dockMgr.Shutdown();
}
BENCHMARK(BM_GetApps);

BENCHMARK_MAIN();
```

### 压力测试

```cpp
// tests/stress/StressTests.cpp
TEST(StressTest, ManyApps) {
  DockManager dockMgr;
  dockMgr.Initialize();
  
  // 添加 1000 个应用
  auto start = std::chrono::high_resolution_clock::now();
  
  for (int i = 0; i < 1000; ++i) {
    dockMgr.AddApp("C:\\app" + std::to_string(i) + ".exe");
  }
  
  auto end = std::chrono::high_resolution_clock::now();
  auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
  
  EXPECT_LT(duration.count(), 5000);  // 应在 5 秒内完成
  
  // 检查内存
  auto memUsage = GetProcessMemoryUsage();
  EXPECT_LT(memUsage, 200 * 1024 * 1024);  // < 200MB
}

TEST(StressTest, ConcurrentAccess) {
  DockManager dockMgr;
  dockMgr.Initialize();
  
  const int numThreads = 10;
  const int opsPerThread = 100;
  
  std::vector<std::thread> threads;
  
  for (int i = 0; i < numThreads; ++i) {
    threads.emplace_back([&dockMgr, i, opsPerThread]() {
      for (int j = 0; j < opsPerThread; ++j) {
        std::string id = dockMgr.AddApp("C:\\app.exe");
        auto apps = dockMgr.GetApps();
        if (!id.empty()) {
          dockMgr.RemoveApp(id);
        }
      }
    });
  }
  
  for (auto& thread : threads) {
    thread.join();
  }
  
  // 验证无崩溃、无死锁
  SUCCEED();
}
```

## 测试覆盖率

### 生成覆盖率报告

```powershell
# 使用 OpenCppCoverage (Windows)
winget install OpenCppCoverage.OpenCppCoverage

# 运行测试并生成报告
OpenCppCoverage.exe `
  --sources "src\*" `
  --export_type html:coverage `
  -- .\build\Debug\CodeCanvasTests.exe

# 查看报告
start coverage\index.html
```

### CI 集成

```yaml
# .github/workflows/coverage.yml
name: Coverage

on: [push, pull_request]

jobs:
  coverage:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Build with coverage
        run: |
          cmake -DCMAKE_BUILD_TYPE=Debug -DENABLE_COVERAGE=ON ..
          cmake --build . --config Debug
      
      - name: Run tests
        run: |
          OpenCppCoverage.exe --sources src -- .\build\Debug\CodeCanvasTests.exe
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.xml
```

## 持续集成

### 完整 CI Pipeline

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: windows-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Environment
        run: |
          # 安装依赖
          
      - name: Lint (C++)
        run: |
          clang-format --dry-run --Werror src/**/*.cpp
      
      - name: Lint (Frontend)
        run: |
          cd frontend
          npm run lint
      
      - name: Unit Tests (C++)
        run: |
          cmake --build build --config Debug
          ctest --output-on-failure
      
      - name: Unit Tests (Frontend)
        run: |
          cd frontend
          npm test
      
      - name: Integration Tests
        run: |
          .\build\Debug\CodeCanvasTests.exe --gtest_filter=*Integration*
      
      - name: Coverage
        run: |
          # 生成覆盖率报告
      
      - name: Performance Tests
        run: |
          .\build\Release\BenchmarkTests.exe
```

## 测试最佳实践

### 1. 编写可测试的代码

```cpp
// ❌ 难以测试（紧耦合）
class DockManager {
  void AddApp(const std::string& path) {
    Database::Instance().Execute("INSERT INTO ...");  // 直接依赖
  }
};

// ✅ 易于测试（依赖注入）
class DockManager {
public:
  DockManager(IDatabase& db) : m_db(db) {}
  
  void AddApp(const std::string& path) {
    m_db.Execute("INSERT INTO ...");  // 可注入 Mock
  }
  
private:
  IDatabase& m_db;
};
```

### 2. AAA 模式

```cpp
TEST(Example, Test) {
  // Arrange（准备）
  DockManager dockMgr;
  std::string path = "C:\\test.exe";
  
  // Act（执行）
  std::string id = dockMgr.AddApp(path);
  
  // Assert（断言）
  ASSERT_FALSE(id.empty());
}
```

### 3. 测试命名

```cpp
// TEST(类名, 方法名_场景_预期结果)
TEST(DockManager, AddApp_ValidPath_ReturnsId)
TEST(DockManager, RemoveApp_NonExistentId_ReturnsFalse)
TEST(ConfigManager, Get_MissingKey_ReturnsDefaultValue)
```

---

*测试是保证代码质量的关键，应持续完善测试覆盖*

