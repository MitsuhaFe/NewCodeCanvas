# 性能优化指南

## 性能目标

| 指标 | 目标值 | 关键 |
|------|--------|------|
| 启动时间 | < 2s | ⭐⭐⭐ |
| 内存占用 | < 100MB | ⭐⭐⭐ |
| CPU 占用（空闲） | < 1% | ⭐⭐⭐ |
| GPU 占用（动态壁纸） | < 5% | ⭐⭐ |
| UI 响应延迟 | < 16ms (60fps) | ⭐⭐⭐ |
| Dock 动画流畅度 | 60fps | ⭐⭐⭐ |

## 性能分析工具

### C++ 性能分析

#### Visual Studio Profiler

```powershell
# 1. 启用性能分析
# Debug -> Performance Profiler (Alt+F2)

# 2. 选择工具
# - CPU Usage
# - Memory Usage
# - GPU Usage

# 3. 启动分析
# Start 按钮

# 4. 查看报告
# 热点函数、调用树、火焰图
```

#### Tracy Profiler

```cpp
// 安装 Tracy
// https://github.com/wolfpld/tracy

// 集成到代码
#include <Tracy.hpp>

void ExpensiveFunction() {
  ZoneScoped;  // 自动计时
  
  // 耗时操作...
}

void Update() {
  ZoneScopedN("MainLoop");
  
  {
    ZoneScopedN("Physics");
    UpdatePhysics();
  }
  
  {
    ZoneScopedN("Rendering");
    Render();
  }
  
  FrameMark;  // 帧标记
}
```

#### Windows Performance Analyzer

```powershell
# 捕获性能数据
wpr -start CPU -start GPU -start FileIO

# 运行应用
.\CodeCanvas.exe

# 停止捕获
wpr -stop performance.etl

# 分析
wpa performance.etl
```

### 前端性能分析

#### Chrome DevTools

```javascript
// 1. 打开 DevTools (F12)
// 2. Performance 面板
// 3. 录制性能数据
// 4. 分析：
//    - Frames (帧率)
//    - Main Thread (主线程活动)
//    - Rendering (渲染时间)
//    - Scripting (脚本执行)
```

#### Vue DevTools

```typescript
// 性能追踪
import { onMounted, onUnmounted } from 'vue'

export default {
  setup() {
    onMounted(() => {
      performance.mark('component-mounted')
    })
    
    onUnmounted(() => {
      performance.mark('component-unmounted')
      performance.measure(
        'component-lifetime',
        'component-mounted',
        'component-unmounted'
      )
      
      const measure = performance.getEntriesByName('component-lifetime')[0]
      console.log(`Component lifetime: ${measure.duration}ms`)
    })
  }
}
```

## C++ 性能优化

### 1. 启动优化

#### 延迟加载

```cpp
class Application {
public:
  bool Initialize() {
    // 核心初始化（快速启动）
    InitializeLogging();
    LoadMinimalConfig();
    CreateMainWindow();
    
    // 显示启动画面
    ShowSplashScreen();
    
    // 后台异步加载
    std::thread([this]() {
      LoadFullConfig();
      LoadWallpapers();
      LoadPetModels();
      InitializeModules();
      
      CloseSplashScreen();
    }).detach();
    
    return true;
  }
};
```

#### 配置缓存

```cpp
class ConfigManager {
private:
  // 使用 mmap 快速加载大配置文件
  bool LoadConfigFast(const std::string& path) {
    HANDLE hFile = CreateFileA(
      path.c_str(),
      GENERIC_READ,
      FILE_SHARE_READ,
      nullptr,
      OPEN_EXISTING,
      FILE_ATTRIBUTE_NORMAL,
      nullptr
    );
    
    if (hFile == INVALID_HANDLE_VALUE) return false;
    
    HANDLE hMapping = CreateFileMapping(hFile, nullptr, PAGE_READONLY, 0, 0, nullptr);
    if (!hMapping) {
      CloseHandle(hFile);
      return false;
    }
    
    void* pData = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
    if (pData) {
      // 解析配置（内存映射，无需复制）
      m_config = nlohmann::json::parse(static_cast<const char*>(pData));
      UnmapViewOfFile(pData);
    }
    
    CloseHandle(hMapping);
    CloseHandle(hFile);
    return true;
  }
};
```

### 2. 内存优化

#### 智能指针

```cpp
// ✅ 使用智能指针
std::unique_ptr<Wallpaper> wallpaper = std::make_unique<Wallpaper>();
std::shared_ptr<DockApp> app = std::make_shared<DockApp>();

// ❌ 避免裸指针
Wallpaper* wallpaper = new Wallpaper();  // 容易泄漏
```

#### 对象池

```cpp
template<typename T>
class ObjectPool {
public:
  ObjectPool(size_t initialSize = 32) {
    m_pool.reserve(initialSize);
  }
  
  template<typename... Args>
  T* Acquire(Args&&... args) {
    if (m_pool.empty()) {
      return new T(std::forward<Args>(args)...);
    }
    
    T* obj = m_pool.back();
    m_pool.pop_back();
    new (obj) T(std::forward<Args>(args)...);  // Placement new
    return obj;
  }
  
  void Release(T* obj) {
    obj->~T();  // 调用析构
    m_pool.push_back(obj);
  }
  
  ~ObjectPool() {
    for (auto* obj : m_pool) {
      delete obj;
    }
  }
  
private:
  std::vector<T*> m_pool;
};

// 使用
ObjectPool<DockItem> dockItemPool;

auto* item = dockItemPool.Acquire(app);
// 使用 item...
dockItemPool.Release(item);
```

#### 内存池

```cpp
class MemoryPool {
public:
  MemoryPool(size_t blockSize, size_t blockCount)
    : m_blockSize(blockSize), m_blockCount(blockCount) {
    m_memory = malloc(blockSize * blockCount);
    
    // 初始化空闲链表
    for (size_t i = 0; i < blockCount; ++i) {
      void* block = static_cast<char*>(m_memory) + i * blockSize;
      m_freeBlocks.push(block);
    }
  }
  
  void* Allocate() {
    if (m_freeBlocks.empty()) return nullptr;
    
    void* block = m_freeBlocks.top();
    m_freeBlocks.pop();
    return block;
  }
  
  void Deallocate(void* block) {
    m_freeBlocks.push(block);
  }
  
  ~MemoryPool() {
    free(m_memory);
  }
  
private:
  void* m_memory;
  size_t m_blockSize;
  size_t m_blockCount;
  std::stack<void*> m_freeBlocks;
};
```

#### RAII 资源管理

```cpp
// Windows 句柄 RAII 封装
class ScopedHandle {
public:
  explicit ScopedHandle(HANDLE handle = INVALID_HANDLE_VALUE)
    : m_handle(handle) {}
  
  ~ScopedHandle() {
    if (m_handle != INVALID_HANDLE_VALUE) {
      CloseHandle(m_handle);
    }
  }
  
  ScopedHandle(const ScopedHandle&) = delete;
  ScopedHandle& operator=(const ScopedHandle&) = delete;
  
  ScopedHandle(ScopedHandle&& other) noexcept
    : m_handle(other.m_handle) {
    other.m_handle = INVALID_HANDLE_VALUE;
  }
  
  HANDLE Get() const { return m_handle; }
  HANDLE* GetAddressOf() { return &m_handle; }
  
private:
  HANDLE m_handle;
};

// 使用
ScopedHandle hFile(CreateFile(...));
if (hFile.Get() == INVALID_HANDLE_VALUE) {
  // 错误处理
}
// 自动关闭
```

### 3. 渲染优化

#### 脏矩形优化

```cpp
class DockWindow {
private:
  RECT m_dirtyRect{0, 0, 0, 0};
  bool m_isDirty = false;
  
  void InvalidateRegion(const RECT& rect) {
    if (!m_isDirty) {
      m_dirtyRect = rect;
      m_isDirty = true;
    } else {
      UnionRect(&m_dirtyRect, &m_dirtyRect, &rect);
    }
  }
  
  void OnPaint() {
    if (!m_isDirty) return;
    
    auto* target = m_renderEngine.GetRenderTarget(m_hwnd);
    target->d2dTarget->BeginDraw();
    
    // 只重绘脏区域
    target->d2dTarget->PushAxisAlignedClip(
      D2D1::RectF(
        m_dirtyRect.left, m_dirtyRect.top,
        m_dirtyRect.right, m_dirtyRect.bottom
      ),
      D2D1_ANTIALIAS_MODE_PER_PRIMITIVE
    );
    
    DrawContent(target);
    
    target->d2dTarget->PopAxisAlignedClip();
    target->d2dTarget->EndDraw();
    
    m_isDirty = false;
  }
};
```

#### 纹理缓存

```cpp
class TextureCache {
public:
  ID2D1Bitmap* GetOrLoad(const std::string& path) {
    auto it = m_cache.find(path);
    if (it != m_cache.end()) {
      // 更新访问时间
      it->second.lastAccess = std::chrono::steady_clock::now();
      return it->second.bitmap.Get();
    }
    
    // 加载纹理
    auto bitmap = LoadBitmap(path);
    if (!bitmap) return nullptr;
    
    // 缓存
    CacheEntry entry;
    entry.bitmap = bitmap;
    entry.size = GetBitmapSize(bitmap.Get());
    entry.lastAccess = std::chrono::steady_clock::now();
    
    m_cache[path] = entry;
    m_currentSize += entry.size;
    
    // 检查缓存大小
    EvictIfNeeded();
    
    return bitmap.Get();
  }
  
private:
  struct CacheEntry {
    Microsoft::WRL::ComPtr<ID2D1Bitmap> bitmap;
    size_t size;
    std::chrono::steady_clock::time_point lastAccess;
  };
  
  void EvictIfNeeded() {
    while (m_currentSize > m_maxSize) {
      // LRU 淘汰
      auto oldest = std::min_element(m_cache.begin(), m_cache.end(),
        [](const auto& a, const auto& b) {
          return a.second.lastAccess < b.second.lastAccess;
        });
      
      if (oldest != m_cache.end()) {
        m_currentSize -= oldest->second.size;
        m_cache.erase(oldest);
      } else {
        break;
      }
    }
  }
  
  std::map<std::string, CacheEntry> m_cache;
  size_t m_maxSize = 100 * 1024 * 1024;  // 100MB
  size_t m_currentSize = 0;
};
```

#### 批量渲染

```cpp
void DockWindow::DrawItems() {
  // 批量绘制相同类型的项
  auto* target = m_renderEngine.GetRenderTarget(m_hwnd);
  
  // 1. 绘制所有背景
  for (const auto& item : m_items) {
    item->DrawBackground(target);
  }
  
  // 2. 绘制所有图标（批量处理）
  for (const auto& item : m_items) {
    item->DrawIcon(target);
  }
  
  // 3. 绘制所有指示器
  for (const auto& item : m_items) {
    if (item->IsRunning()) {
      item->DrawIndicator(target);
    }
  }
}
```

### 4. 多线程优化

#### 线程池

```cpp
class ThreadPool {
public:
  ThreadPool(size_t numThreads = std::thread::hardware_concurrency()) {
    for (size_t i = 0; i < numThreads; ++i) {
      m_workers.emplace_back([this] {
        while (true) {
          std::function<void()> task;
          
          {
            std::unique_lock<std::mutex> lock(m_mutex);
            m_condition.wait(lock, [this] {
              return m_stop || !m_tasks.empty();
            });
            
            if (m_stop && m_tasks.empty()) return;
            
            task = std::move(m_tasks.front());
            m_tasks.pop();
          }
          
          task();
        }
      });
    }
  }
  
  template<typename F, typename... Args>
  auto Enqueue(F&& f, Args&&... args) 
    -> std::future<typename std::invoke_result<F, Args...>::type> {
    using ReturnType = typename std::invoke_result<F, Args...>::type;
    
    auto task = std::make_shared<std::packaged_task<ReturnType()>>(
      std::bind(std::forward<F>(f), std::forward<Args>(args)...)
    );
    
    std::future<ReturnType> res = task->get_future();
    
    {
      std::unique_lock<std::mutex> lock(m_mutex);
      if (m_stop) throw std::runtime_error("Enqueue on stopped ThreadPool");
      m_tasks.emplace([task]() { (*task)(); });
    }
    
    m_condition.notify_one();
    return res;
  }
  
  ~ThreadPool() {
    {
      std::unique_lock<std::mutex> lock(m_mutex);
      m_stop = true;
    }
    m_condition.notify_all();
    for (auto& worker : m_workers) {
      worker.join();
    }
  }
  
private:
  std::vector<std::thread> m_workers;
  std::queue<std::function<void()>> m_tasks;
  std::mutex m_mutex;
  std::condition_variable m_condition;
  bool m_stop = false;
};
```

#### 异步 I/O

```cpp
class AsyncFileLoader {
public:
  std::future<std::vector<uint8_t>> LoadAsync(const std::string& path) {
    return std::async(std::launch::async, [path]() {
      std::ifstream file(path, std::ios::binary);
      if (!file) throw std::runtime_error("File not found");
      
      file.seekg(0, std::ios::end);
      size_t size = file.tellg();
      file.seekg(0, std::ios::beg);
      
      std::vector<uint8_t> data(size);
      file.read(reinterpret_cast<char*>(data.data()), size);
      
      return data;
    });
  }
};

// 使用
AsyncFileLoader loader;
auto future = loader.LoadAsync("wallpaper.jpg");

// 继续其他工作...

// 需要数据时
auto data = future.get();
```

### 5. 数据结构优化

#### 使用合适的容器

```cpp
// ❌ 频繁随机访问用 list
std::list<DockApp> apps;  // O(n) 查找

// ✅ 使用 vector
std::vector<DockApp> apps;  // O(1) 随机访问，缓存友好

// ❌ 需要快速查找用 vector
for (auto& app : apps) {  // O(n)
  if (app.id == targetId) { ... }
}

// ✅ 使用 unordered_map
std::unordered_map<std::string, DockApp> apps;  // O(1) 查找
auto it = apps.find(targetId);
```

#### 预分配容量

```cpp
// ❌ 频繁扩容
std::vector<Wallpaper> wallpapers;
for (int i = 0; i < 1000; ++i) {
  wallpapers.push_back(LoadWallpaper(i));  // 多次重新分配
}

// ✅ 预分配
std::vector<Wallpaper> wallpapers;
wallpapers.reserve(1000);  // 一次分配
for (int i = 0; i < 1000; ++i) {
  wallpapers.push_back(LoadWallpaper(i));
}
```

#### 移动语义

```cpp
// ❌ 不必要的拷贝
Wallpaper CreateWallpaper() {
  Wallpaper wp;
  wp.LoadFromFile("...");
  return wp;  // C++11 之前会拷贝
}

// ✅ 返回值优化 + 移动语义
Wallpaper CreateWallpaper() {
  Wallpaper wp;
  wp.LoadFromFile("...");
  return wp;  // 现代 C++ 自动移动
}

// 存储时使用 emplace
std::vector<Wallpaper> wallpapers;
wallpapers.emplace_back(CreateWallpaper());  // 移动构造
```

## 前端性能优化

### 1. 组件优化

#### 虚拟列表

```vue
<template>
  <div class="virtual-list" @scroll="handleScroll">
    <div :style="{ height: totalHeight + 'px' }">
      <div
        v-for="item in visibleItems"
        :key="item.id"
        :style="{ transform: `translateY(${item.offsetY}px)` }"
        class="list-item"
      >
        {{ item.name }}
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'

const props = defineProps<{
  items: any[]
  itemHeight: number
}>()

const scrollTop = ref(0)
const containerHeight = 600

const visibleItems = computed(() => {
  const startIndex = Math.floor(scrollTop.value / props.itemHeight)
  const endIndex = Math.ceil((scrollTop.value + containerHeight) / props.itemHeight)
  
  return props.items
    .slice(startIndex, endIndex)
    .map((item, index) => ({
      ...item,
      offsetY: (startIndex + index) * props.itemHeight
    }))
})

const totalHeight = computed(() => props.items.length * props.itemHeight)

const handleScroll = (e: Event) => {
  scrollTop.value = (e.target as HTMLElement).scrollTop
}
</script>
```

#### Memoization

```typescript
import { computed, ref } from 'vue'

const expensiveData = ref<number[]>([])

// ❌ 每次重新计算
const processedData = computed(() => {
  return expensiveData.value.map(x => x * 2).filter(x => x > 10)
})

// ✅ 缓存结果
const cachedProcessedData = computed(() => {
  const cache = new Map()
  
  return expensiveData.value.map(x => {
    if (cache.has(x)) return cache.get(x)
    
    const result = x * 2
    cache.set(x, result)
    return result
  }).filter(x => x > 10)
})
```

### 2. 渲染优化

#### v-once 和 v-memo

```vue
<template>
  <!-- 只渲染一次 -->
  <div v-once>
    <h1>{{ staticTitle }}</h1>
  </div>
  
  <!-- 缓存子树（Vue 3.2+） -->
  <div v-memo="[item.id, item.selected]">
    <ItemComponent :item="item" />
  </div>
</template>
```

#### 异步组件

```typescript
import { defineAsyncComponent } from 'vue'

// 懒加载大组件
const HeavyComponent = defineAsyncComponent(() =>
  import('./HeavyComponent.vue')
)

// 带加载状态
const HeavyComponent = defineAsyncComponent({
  loader: () => import('./HeavyComponent.vue'),
  loadingComponent: LoadingSpinner,
  errorComponent: ErrorComponent,
  delay: 200,
  timeout: 3000
})
```

### 3. 状态管理优化

#### Pinia 优化

```typescript
// stores/wallpaper.ts
import { defineStore } from 'pinia'
import { computed, ref } from 'vue'

export const useWallpaperStore = defineStore('wallpaper', () => {
  const wallpapers = ref<Wallpaper[]>([])
  
  // ✅ 使用 computed 缓存
  const favoriteWallpapers = computed(() =>
    wallpapers.value.filter(w => w.isFavorite)
  )
  
  // ✅ 批量更新
  const batchUpdate = (updates: Wallpaper[]) => {
    // 一次更新，减少重新渲染
    wallpapers.value = [
      ...wallpapers.value.filter(w => !updates.some(u => u.id === w.id)),
      ...updates
    ]
  }
  
  return { wallpapers, favoriteWallpapers, batchUpdate }
})
```

### 4. 资源优化

#### 图片懒加载

```vue
<template>
  <img
    v-lazy="wallpaper.thumbnailPath"
    :alt="wallpaper.name"
  />
</template>

<script setup lang="ts">
import { directive as vLazy } from 'vue3-lazyload'
</script>
```

#### 代码分割

```typescript
// router/index.ts
const routes = [
  {
    path: '/settings',
    component: () => import('@/views/Settings.vue')  // 路由级懒加载
  }
]
```

## 性能监控

### 运行时监控

```cpp
// src/core/PerformanceMonitor.h
class PerformanceMonitor {
public:
  static PerformanceMonitor& Instance();
  
  void RecordFrameTime(double deltaTime) {
    m_frameTimes.push_back(deltaTime);
    if (m_frameTimes.size() > 60) {
      m_frameTimes.erase(m_frameTimes.begin());
    }
  }
  
  double GetAverageFPS() const {
    if (m_frameTimes.empty()) return 0.0;
    
    double avg = std::accumulate(m_frameTimes.begin(), m_frameTimes.end(), 0.0)
      / m_frameTimes.size();
    return 1.0 / avg;
  }
  
  size_t GetMemoryUsage() const {
    PROCESS_MEMORY_COUNTERS_EX pmc;
    GetProcessMemoryInfo(GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*)&pmc, sizeof(pmc));
    return pmc.WorkingSetSize / 1024 / 1024;  // MB
  }
  
  double GetCPUUsage() const {
    // 使用 PDH (Performance Data Helper) API
    // ...
  }
  
private:
  std::vector<double> m_frameTimes;
};
```

### 性能日志

```cpp
// 性能关键路径记录
void ExpensiveFunction() {
  auto start = std::chrono::high_resolution_clock::now();
  
  // 耗时操作...
  
  auto end = std::chrono::high_resolution_clock::now();
  auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
  
  if (duration.count() > 16) {  // 超过一帧时间
    spdlog::warn("ExpensiveFunction took {}ms (> 16ms)", duration.count());
  }
}
```

---

*性能优化是持续的过程，需要根据实际测试结果不断调整*

