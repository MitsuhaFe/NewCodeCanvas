# 系统架构设计

## 整体架构

### 分层架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                    表示层 (Presentation Layer)                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │  Dock UI     │  │ Wallpaper UI │  │   Pet UI     │          │
│  │  (Vue 3)     │  │  (Vue 3)     │  │  (Vue 3)     │          │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘          │
│         │                 │                  │                   │
│         └─────────────────┴──────────────────┘                   │
│                           │                                      │
│                  ┌────────▼────────┐                            │
│                  │  Pinia Store    │                            │
│                  │  (状态管理)      │                            │
│                  └────────┬────────┘                            │
└───────────────────────────┼──────────────────────────────────────┘
                            │ WebView2 Bridge
┌───────────────────────────▼──────────────────────────────────────┐
│                  通信层 (Communication Layer)                     │
│  ┌────────────────────────────────────────────────────────┐     │
│  │              IPC Manager (C++)                         │     │
│  │  - JSON-RPC Handler                                    │     │
│  │  - Message Queue                                        │     │
│  │  - Event Dispatcher                                     │     │
│  └────────────────────────┬───────────────────────────────┘     │
└───────────────────────────┼──────────────────────────────────────┘
                            │
┌───────────────────────────▼──────────────────────────────────────┐
│                  业务逻辑层 (Business Logic Layer)                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ Dock Manager │  │Wallpaper Mgr │  │  Pet Manager │          │
│  │   (C++)      │  │   (C++)      │  │    (C++)     │          │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘          │
│         │                 │                  │                   │
│         └─────────────────┴──────────────────┘                   │
│                           │                                      │
│         ┌─────────────────┴─────────────────┐                   │
│         │                                   │                   │
│   ┌─────▼──────┐                   ┌────────▼────────┐          │
│   │App Launcher│                   │  Resource Mgr   │          │
│   │   (C++)    │                   │     (C++)       │          │
│   └────────────┘                   └─────────────────┘          │
└───────────────────────────┬──────────────────────────────────────┘
                            │
┌───────────────────────────▼──────────────────────────────────────┐
│                  核心层 (Core Layer)                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │Window Manager│  │Render Engine │  │  File System │          │
│  │   (C++)      │  │   (C++)      │  │    (C++)     │          │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘          │
│         │                 │                  │                   │
│  ┌──────▼───────┐  ┌──────▼───────┐  ┌──────▼───────┐          │
│  │Event System  │  │Thread Pool   │  │Config Manager│          │
│  │   (C++)      │  │   (C++)      │  │    (C++)     │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
└───────────────────────────┬──────────────────────────────────────┘
                            │
┌───────────────────────────▼──────────────────────────────────────┐
│                  平台层 (Platform Layer)                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │  Win32 API  │  │  Direct2D   │  │ DirectX 11  │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │   SQLite    │  │   FFmpeg    │  │  WebView2   │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
└──────────────────────────────────────────────────────────────────┘
```

## 核心模块设计

### 1. Application Core（应用核心）

**职责**：
- 应用程序生命周期管理
- 全局事件循环
- 模块初始化与销毁
- 异常处理

**类设计**：
```cpp
// src/core/Application.h
class Application {
public:
  static Application& Instance();
  
  bool Initialize();
  int Run();
  void Shutdown();
  
  // 模块访问
  WindowManager& GetWindowManager();
  DockManager& GetDockManager();
  WallpaperManager& GetWallpaperManager();
  PetManager& GetPetManager();
  
private:
  Application();
  ~Application();
  
  void InitializeLogging();
  void LoadConfiguration();
  void RegisterModules();
  
  std::unique_ptr<WindowManager> m_windowManager;
  std::unique_ptr<DockManager> m_dockManager;
  std::unique_ptr<WallpaperManager> m_wallpaperManager;
  std::unique_ptr<PetManager> m_petManager;
  std::unique_ptr<IPCManager> m_ipcManager;
  
  bool m_isRunning;
};
```

**初始化流程**：
```
Application::Initialize()
    │
    ├─> InitializeLogging()        // 初始化日志系统
    ├─> LoadConfiguration()        // 加载配置文件
    ├─> InitDatabase()             // 初始化数据库
    ├─> CreateWindowManager()      // 创建窗口管理器
    ├─> CreateIPCManager()         // 创建 IPC 管理器
    ├─> CreateModules()            // 创建业务模块
    │   ├─> DockManager
    │   ├─> WallpaperManager
    │   └─> PetManager
    └─> StartEventLoop()           // 启动事件循环
```

### 2. Window Manager（窗口管理器）

**职责**：
- 创建和管理所有窗口
- 处理窗口消息
- 窗口层级控制
- 多显示器支持

**类设计**：
```cpp
// src/core/WindowManager.h
enum class WindowType {
  Dock,
  Wallpaper,
  Pet,
  Settings,
  Unknown
};

struct WindowConfig {
  WindowType type;
  std::wstring title;
  int width, height;
  int x, y;
  DWORD style;
  DWORD exStyle;
  bool layered;
  bool topmost;
};

class BaseWindow {
public:
  virtual ~BaseWindow() = default;
  
  virtual bool Create(const WindowConfig& config);
  virtual void Destroy();
  virtual void Show();
  virtual void Hide();
  virtual void Update();
  
  HWND GetHandle() const { return m_hwnd; }
  WindowType GetType() const { return m_type; }
  
protected:
  virtual LRESULT HandleMessage(UINT msg, WPARAM wParam, LPARAM lParam);
  
  HWND m_hwnd = nullptr;
  WindowType m_type = WindowType::Unknown;
  WindowConfig m_config;
};

class WindowManager {
public:
  WindowManager();
  ~WindowManager();
  
  template<typename T>
  std::shared_ptr<T> CreateWindow(const WindowConfig& config);
  
  void DestroyWindow(HWND hwnd);
  BaseWindow* GetWindow(HWND hwnd);
  std::vector<BaseWindow*> GetWindowsByType(WindowType type);
  
  // 显示器管理
  std::vector<MonitorInfo> GetMonitors();
  MonitorInfo GetPrimaryMonitor();
  
private:
  static LRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
  
  std::map<HWND, std::shared_ptr<BaseWindow>> m_windows;
  std::mutex m_mutex;
};
```

**窗口层级策略**：
```
层级从低到高：
┌────────────────────────┐
│  桌面图标               │ Desktop (底层)
├────────────────────────┤
│  壁纸窗口               │ HWND_BOTTOM
│  (WallpaperWindow)     │ WS_EX_NOACTIVATE
├────────────────────────┤
│  普通应用窗口           │ 正常层级
├────────────────────────┤
│  Dock 窗口              │ WS_EX_TOPMOST (可选)
│  (DockWindow)          │ WS_EX_TOOLWINDOW
├────────────────────────┤
│  桌宠窗口               │ WS_EX_TOPMOST
│  (PetWindow)           │ WS_EX_LAYERED | WS_EX_TRANSPARENT
├────────────────────────┤
│  设置窗口               │ 最高层级（激活时）
│  (SettingsWindow)      │
└────────────────────────┘
```

### 3. Render Engine（渲染引擎）

**职责**：
- 管理 Direct2D/DirectX 设备
- 提供渲染接口
- 处理资源加载和缓存
- 动画系统

**类设计**：
```cpp
// src/render/RenderEngine.h
class RenderEngine {
public:
  struct RenderTarget {
    ID2D1HwndRenderTarget* d2dTarget;
    ID3D11RenderTargetView* d3dTarget;
    HWND hwnd;
  };
  
  RenderEngine();
  ~RenderEngine();
  
  bool Initialize();
  void Shutdown();
  
  // 渲染目标管理
  RenderTarget* CreateRenderTarget(HWND hwnd, int width, int height);
  void DestroyRenderTarget(RenderTarget* target);
  void ResizeRenderTarget(RenderTarget* target, int width, int height);
  
  // Direct2D 绘制
  void BeginDraw(RenderTarget* target);
  void EndDraw(RenderTarget* target);
  void Clear(RenderTarget* target, const D2D1_COLOR_F& color);
  
  // 资源创建
  ID2D1SolidColorBrush* CreateSolidBrush(const D2D1_COLOR_F& color);
  ID2D1Bitmap* LoadBitmap(const std::wstring& path);
  
  // DirectX 11（动态壁纸/桌宠）
  ID3D11Device* GetD3DDevice() { return m_d3dDevice.Get(); }
  ID3D11DeviceContext* GetD3DContext() { return m_d3dContext.Get(); }
  
private:
  void CreateD2DResources();
  void CreateD3DResources();
  
  // Direct2D
  Microsoft::WRL::ComPtr<ID2D1Factory> m_d2dFactory;
  Microsoft::WRL::ComPtr<IDWriteFactory> m_dwriteFactory;
  
  // DirectX 11
  Microsoft::WRL::ComPtr<ID3D11Device> m_d3dDevice;
  Microsoft::WRL::ComPtr<ID3D11DeviceContext> m_d3dContext;
  Microsoft::WRL::ComPtr<IDXGISwapChain> m_swapChain;
  
  std::map<HWND, std::unique_ptr<RenderTarget>> m_renderTargets;
};
```

**渲染流程**：
```cpp
// 典型渲染循环（Dock 窗口示例）
void DockWindow::OnPaint() {
  auto* target = m_renderEngine->CreateRenderTarget(m_hwnd, width, height);
  
  m_renderEngine->BeginDraw(target);
  m_renderEngine->Clear(target, D2D1::ColorF(D2D1::ColorF::Black, 0.8f));
  
  // 绘制 Dock 背景
  DrawBackground(target);
  
  // 绘制图标
  for (auto& item : m_dockItems) {
    item->Draw(target);
  }
  
  // 绘制分隔符
  DrawSeparators(target);
  
  m_renderEngine->EndDraw(target);
}
```

### 4. IPC Manager（进程间通信管理器）

**职责**：
- WebView2 消息路由
- JSON-RPC 协议处理
- 事件订阅/发布
- 异步请求管理

**类设计**：
```cpp
// src/ipc/IPCManager.h
using MessageHandler = std::function<nlohmann::json(const nlohmann::json&)>;
using EventCallback = std::function<void(const nlohmann::json&)>;

class IPCManager {
public:
  IPCManager(ICoreWebView2* webView);
  ~IPCManager();
  
  // 注册方法处理器
  void RegisterMethod(const std::string& method, MessageHandler handler);
  void UnregisterMethod(const std::string& method);
  
  // 发送消息到前端
  void PostMessage(const std::string& method, const nlohmann::json& params);
  void PostEvent(const std::string& event, const nlohmann::json& data);
  
  // 调用前端方法（异步）
  std::future<nlohmann::json> CallMethod(
    const std::string& method, 
    const nlohmann::json& params
  );
  
private:
  void OnMessageReceived(const std::string& message);
  void HandleRequest(const nlohmann::json& request);
  void HandleResponse(const nlohmann::json& response);
  
  ICoreWebView2* m_webView;
  std::map<std::string, MessageHandler> m_handlers;
  std::map<int, std::promise<nlohmann::json>> m_pendingRequests;
  std::atomic<int> m_nextRequestId{1};
  std::mutex m_mutex;
};
```

**消息路由表**：
```cpp
// IPC 方法注册示例
void RegisterIPCMethods(IPCManager& ipc, DockManager& dock) {
  // Dock 相关
  ipc.RegisterMethod("dock.getApps", [&](const auto& params) {
    return dock.GetApps();
  });
  
  ipc.RegisterMethod("dock.addApp", [&](const auto& params) {
    std::string path = params["path"];
    return dock.AddApp(path);
  });
  
  ipc.RegisterMethod("dock.removeApp", [&](const auto& params) {
    std::string id = params["id"];
    return dock.RemoveApp(id);
  });
  
  ipc.RegisterMethod("dock.setPosition", [&](const auto& params) {
    std::string position = params["position"];
    return dock.SetPosition(position);
  });
  
  // 更多方法...
}
```

### 5. Event System（事件系统）

**职责**：
- 跨模块事件通信
- 异步事件分发
- 事件优先级管理

**类设计**：
```cpp
// src/core/EventSystem.h
enum class EventType {
  // 应用事件
  AppStarted,
  AppShutdown,
  
  // Dock 事件
  DockAppAdded,
  DockAppRemoved,
  DockAppLaunched,
  
  // 壁纸事件
  WallpaperChanged,
  WallpaperLoaded,
  
  // 桌宠事件
  PetSpawned,
  PetDestroyed,
  PetInteraction,
  
  // 系统事件
  MonitorChanged,
  ThemeChanged,
  
  Custom = 1000
};

struct Event {
  EventType type;
  nlohmann::json data;
  std::chrono::system_clock::time_point timestamp;
  int priority = 0;  // 数值越大优先级越高
};

using EventListener = std::function<void(const Event&)>;

class EventSystem {
public:
  static EventSystem& Instance();
  
  // 订阅事件
  int Subscribe(EventType type, EventListener listener, int priority = 0);
  void Unsubscribe(int listenerId);
  
  // 发布事件
  void Publish(EventType type, const nlohmann::json& data = {}, int priority = 0);
  void PublishAsync(EventType type, const nlohmann::json& data = {}, int priority = 0);
  
  // 事件处理
  void ProcessEvents();  // 处理队列中的事件
  
private:
  EventSystem();
  
  struct Listener {
    int id;
    EventType type;
    EventListener callback;
    int priority;
  };
  
  std::multimap<EventType, Listener> m_listeners;
  std::priority_queue<Event> m_eventQueue;
  std::mutex m_mutex;
  int m_nextListenerId = 1;
};
```

**使用示例**：
```cpp
// 订阅事件
EventSystem::Instance().Subscribe(
  EventType::WallpaperChanged,
  [](const Event& e) {
    std::string wallpaperId = e.data["id"];
    spdlog::info("Wallpaper changed to: {}", wallpaperId);
    // 更新 UI...
  }
);

// 发布事件
nlohmann::json data;
data["id"] = "wallpaper-123";
data["type"] = "video";
EventSystem::Instance().Publish(EventType::WallpaperChanged, data);
```

## 线程模型

### 线程设计

```
┌─────────────────────────────────────────────────────────┐
│  Main Thread (UI Thread)                                │
│  - Windows 消息循环                                      │
│  - Direct2D 渲染                                        │
│  - WebView2 交互                                        │
│  - 事件分发                                             │
└─────────────────────────────────────────────────────────┘
            │
            ├─> Post Task
            ▼
┌─────────────────────────────────────────────────────────┐
│  Render Thread                                          │
│  - DirectX 11 渲染（动态壁纸/桌宠）                      │
│  - 视频解码                                             │
│  - 帧缓冲管理                                           │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│  IO Thread                                              │
│  - 文件读写                                             │
│  - 数据库操作                                           │
│  - 网络请求                                             │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│  Worker Thread Pool (4 threads)                         │
│  - 图片处理                                             │
│  - 缩略图生成                                           │
│  - 数据计算                                             │
└─────────────────────────────────────────────────────────┘
```

### 线程池实现

```cpp
// src/core/ThreadPool.h
class ThreadPool {
public:
  ThreadPool(size_t numThreads = std::thread::hardware_concurrency());
  ~ThreadPool();
  
  template<typename F, typename... Args>
  auto Enqueue(F&& f, Args&&... args) 
    -> std::future<typename std::invoke_result<F, Args...>::type>;
  
  void Wait();  // 等待所有任务完成
  
private:
  std::vector<std::thread> m_workers;
  std::queue<std::function<void()>> m_tasks;
  std::mutex m_mutex;
  std::condition_variable m_condition;
  bool m_stop = false;
};

// 使用示例
auto future = ThreadPool::Instance().Enqueue([](const std::string& path) {
  return LoadImageThumbnail(path);
}, imagePath);

auto thumbnail = future.get();  // 阻塞等待结果
```

## 资源管理

### Resource Manager（资源管理器）

**职责**：
- 统一资源加载
- 资源缓存
- 内存管理
- 资源引用计数

**类设计**：
```cpp
// src/core/ResourceManager.h
enum class ResourceType {
  Image,
  Video,
  Icon,
  Font,
  Model,
  Script
};

template<typename T>
class Resource {
public:
  Resource(const std::string& path) : m_path(path), m_refCount(0) {}
  
  std::shared_ptr<T> Load();
  void Unload();
  
  int GetRefCount() const { return m_refCount; }
  const std::string& GetPath() const { return m_path; }
  
private:
  std::string m_path;
  std::shared_ptr<T> m_data;
  std::atomic<int> m_refCount;
};

class ResourceManager {
public:
  static ResourceManager& Instance();
  
  // 加载资源
  std::shared_ptr<ID2D1Bitmap> LoadImage(const std::string& path);
  std::shared_ptr<IDWriteTextFormat> LoadFont(const std::string& name, float size);
  
  // 缓存管理
  void SetCacheSize(size_t maxSizeMB);
  void ClearCache();
  size_t GetCacheSize() const;
  
  // 预加载
  void PreloadResources(const std::vector<std::string>& paths);
  
private:
  ResourceManager();
  
  template<typename T>
  std::shared_ptr<T> GetCached(const std::string& key);
  
  template<typename T>
  void Cache(const std::string& key, std::shared_ptr<T> resource);
  
  struct CacheEntry {
    std::shared_ptr<void> data;
    size_t size;
    std::chrono::system_clock::time_point lastAccess;
  };
  
  std::map<std::string, CacheEntry> m_cache;
  size_t m_maxCacheSize;
  std::mutex m_mutex;
};
```

## 配置管理

### Config Manager（配置管理器）

**配置文件格式**：JSON
**位置**：`%APPDATA%/CodeCanvas/config.json`

```json
{
  "version": "1.0.0",
  "dock": {
    "position": "bottom",
    "autoHide": false,
    "iconSize": 48,
    "apps": [
      {
        "id": "app-1",
        "path": "C:\\Program Files\\Example\\app.exe",
        "icon": "custom-icon.png",
        "position": 0
      }
    ]
  },
  "wallpaper": {
    "activeId": "wallpaper-1",
    "autoChange": true,
    "interval": 3600,
    "monitors": {
      "monitor-1": "wallpaper-1",
      "monitor-2": "wallpaper-2"
    }
  },
  "pet": {
    "enabled": true,
    "activeId": "pet-1",
    "scale": 1.0,
    "interactionEnabled": true
  },
  "general": {
    "language": "zh-CN",
    "theme": "dark",
    "startWithSystem": true,
    "checkUpdates": true
  }
}
```

**类设计**：
```cpp
// src/core/ConfigManager.h
class ConfigManager {
public:
  static ConfigManager& Instance();
  
  bool Load(const std::string& path = "");
  bool Save(const std::string& path = "");
  
  // 读取配置
  template<typename T>
  T Get(const std::string& key, const T& defaultValue = T{});
  
  // 写入配置
  template<typename T>
  void Set(const std::string& key, const T& value);
  
  // 配置变更通知
  using ChangeCallback = std::function<void(const std::string&, const nlohmann::json&)>;
  void OnChange(const std::string& key, ChangeCallback callback);
  
private:
  ConfigManager();
  
  nlohmann::json m_config;
  std::map<std::string, std::vector<ChangeCallback>> m_callbacks;
  std::string m_configPath;
  std::mutex m_mutex;
};

// 使用示例
int iconSize = ConfigManager::Instance().Get<int>("dock.iconSize", 48);
ConfigManager::Instance().Set("dock.autoHide", true);
```

## 错误处理

### 错误处理策略

```cpp
// src/core/Error.h
enum class ErrorCode {
  Success = 0,
  
  // 通用错误 (1-99)
  UnknownError = 1,
  InvalidParameter = 2,
  OutOfMemory = 3,
  FileNotFound = 4,
  
  // Dock 错误 (100-199)
  DockAppNotFound = 100,
  DockAppAlreadyExists = 101,
  DockLaunchFailed = 102,
  
  // 壁纸错误 (200-299)
  WallpaperLoadFailed = 200,
  WallpaperFormatUnsupported = 201,
  WallpaperDecodeFailed = 202,
  
  // 桌宠错误 (300-399)
  PetModelNotFound = 300,
  PetAnimationFailed = 301,
  
  // 系统错误 (400-499)
  WindowCreationFailed = 400,
  RenderInitFailed = 401,
  IPCFailed = 402
};

class Exception : public std::exception {
public:
  Exception(ErrorCode code, const std::string& message)
    : m_code(code), m_message(message) {}
  
  ErrorCode GetCode() const { return m_code; }
  const char* what() const noexcept override { return m_message.c_str(); }
  
private:
  ErrorCode m_code;
  std::string m_message;
};

// 使用宏简化异常抛出
#define THROW_ERROR(code, msg) \
  throw Exception(code, std::string(__FILE__) + ":" + std::to_string(__LINE__) + " - " + msg)

// 使用示例
try {
  if (!LoadWallpaper(path)) {
    THROW_ERROR(ErrorCode::WallpaperLoadFailed, "Failed to load: " + path);
  }
} catch (const Exception& e) {
  spdlog::error("Error {}: {}", static_cast<int>(e.GetCode()), e.what());
  // 向前端报告错误
  ipc.PostEvent("error", {
    {"code", static_cast<int>(e.GetCode())},
    {"message", e.what()}
  });
}
```

---

*此架构设计文档将随着开发进展持续更新*

