# 模块设计文档

## 模块概览

CodeCanvas 由三个核心功能模块组成，每个模块独立设计，通过事件系统和 IPC 进行通信。

```
Core Modules
├── Dock Module        # Dock 栏模块
├── Wallpaper Module   # 壁纸管理模块
└── Pet Module         # 虚拟桌宠模块
```

---

## 1. Dock 模块

### 1.1 模块职责

- 应用程序快速启动
- 运行中应用检测与管理
- 图标渲染与动画
- 自定义布局与主题

### 1.2 类设计

```cpp
// src/modules/dock/DockManager.h
class DockManager {
public:
  DockManager(WindowManager& windowMgr, RenderEngine& renderEngine);
  ~DockManager();
  
  bool Initialize();
  void Shutdown();
  
  // 应用管理
  std::string AddApp(const std::string& path);
  bool RemoveApp(const std::string& id);
  bool MoveApp(const std::string& id, int newPosition);
  nlohmann::json GetApps() const;
  
  // Dock 配置
  void SetPosition(DockPosition position);
  void SetAutoHide(bool enable);
  void SetIconSize(int size);
  void SetTheme(const std::string& themeId);
  
  // 应用启动
  bool LaunchApp(const std::string& id);
  bool CloseApp(const std::string& id);
  
  // 运行中应用
  void UpdateRunningApps();
  std::vector<RunningApp> GetRunningApps() const;
  
private:
  void CreateDockWindow();
  void LoadAppsFromConfig();
  void SaveAppsToConfig();
  void UpdateLayout();
  
  std::unique_ptr<DockWindow> m_window;
  std::vector<std::unique_ptr<DockItem>> m_items;
  DockConfig m_config;
  
  WindowManager& m_windowManager;
  RenderEngine& m_renderEngine;
};
```

### 1.3 核心数据结构

```cpp
// Dock 位置
enum class DockPosition {
  Top,
  Bottom,
  Left,
  Right
};

// Dock 应用项
struct DockApp {
  std::string id;              // 唯一标识符
  std::string name;            // 应用名称
  std::string path;            // 可执行文件路径
  std::string iconPath;        // 自定义图标路径（可选）
  int position;                // 排序位置
  bool isPinned;               // 是否固定
  
  nlohmann::json ToJson() const;
  static DockApp FromJson(const nlohmann::json& json);
};

// 运行中应用
struct RunningApp {
  HWND hwnd;                   // 窗口句柄
  DWORD processId;             // 进程 ID
  std::string title;           // 窗口标题
  std::string exePath;         // 可执行文件路径
  HICON icon;                  // 窗口图标
  bool isMinimized;            // 是否最小化
};

// Dock 配置
struct DockConfig {
  DockPosition position = DockPosition::Bottom;
  bool autoHide = false;
  int iconSize = 48;           // 图标大小（像素）
  int maxIconSize = 64;        // 鼠标悬停最大放大
  float spacing = 8.0f;        // 图标间距
  float margin = 10.0f;        // 边距
  float cornerRadius = 12.0f;  // 圆角半径
  D2D1_COLOR_F bgColor = D2D1::ColorF(0x1E1E1E, 0.8f);  // 背景色
  std::string themeId = "default";
};
```

### 1.4 DockWindow 设计

```cpp
// src/modules/dock/DockWindow.h
class DockWindow : public BaseWindow {
public:
  DockWindow(RenderEngine& renderEngine);
  
  bool Create(const DockConfig& config);
  void Update(const DockConfig& config);
  void AddItem(std::unique_ptr<DockItem> item);
  void RemoveItem(const std::string& id);
  void UpdateLayout();
  
protected:
  LRESULT HandleMessage(UINT msg, WPARAM wParam, LPARAM lParam) override;
  void OnPaint();
  void OnMouseMove(int x, int y);
  void OnMouseLeave();
  void OnLButtonDown(int x, int y);
  void OnRButtonDown(int x, int y);
  
private:
  void CalculateSize();
  void CalculateItemPositions();
  void DrawBackground(ID2D1HwndRenderTarget* target);
  void DrawItems(ID2D1HwndRenderTarget* target);
  void AnimateItems(float deltaTime);
  
  // 自动隐藏
  void StartAutoHideTimer();
  void ShowDock();
  void HideDock();
  
  RenderEngine& m_renderEngine;
  std::vector<std::unique_ptr<DockItem>> m_items;
  DockConfig m_config;
  
  // 动画状态
  struct AnimationState {
    float hoverX = -1.0f;      // 鼠标悬停 X 坐标
    float currentOpacity = 1.0f;
    bool isAnimating = false;
  } m_animState;
  
  // 性能优化
  std::chrono::steady_clock::time_point m_lastFrame;
  bool m_needsRedraw = true;
};
```

### 1.5 DockItem 设计

```cpp
// src/modules/dock/DockItem.h
class DockItem {
public:
  DockItem(const DockApp& app);
  
  void Draw(ID2D1HwndRenderTarget* target, const D2D1_RECT_F& rect);
  void Update(float deltaTime);
  
  // 动画
  void SetHoverAmount(float amount);  // 0.0 - 1.0
  void SetScale(float scale);
  void Bounce();  // 启动应用时的弹跳动画
  
  // 属性
  const std::string& GetId() const { return m_app.id; }
  const DockApp& GetApp() const { return m_app; }
  bool IsRunning() const { return m_isRunning; }
  void SetRunning(bool running) { m_isRunning = running; }
  
  // 点击检测
  bool HitTest(int x, int y) const;
  
private:
  void LoadIcon();
  void DrawIcon(ID2D1HwndRenderTarget* target, const D2D1_RECT_F& rect);
  void DrawRunningIndicator(ID2D1HwndRenderTarget* target, const D2D1_RECT_F& rect);
  void DrawBadge(ID2D1HwndRenderTarget* target, const D2D1_RECT_F& rect);
  
  DockApp m_app;
  Microsoft::WRL::ComPtr<ID2D1Bitmap> m_iconBitmap;
  
  // 状态
  bool m_isRunning = false;
  int m_badgeCount = 0;
  
  // 动画
  float m_currentScale = 1.0f;
  float m_targetScale = 1.0f;
  float m_hoverAmount = 0.0f;
  float m_bouncePhase = 0.0f;
};
```

### 1.6 应用启动流程

```cpp
bool DockManager::LaunchApp(const std::string& id) {
  auto it = std::find_if(m_items.begin(), m_items.end(),
    [&id](const auto& item) { return item->GetId() == id; });
  
  if (it == m_items.end()) {
    return false;
  }
  
  const auto& app = (*it)->GetApp();
  
  // 1. 检查是否已运行
  if ((*it)->IsRunning()) {
    // 如果已运行，激活窗口
    ActivateRunningApp(app.path);
    return true;
  }
  
  // 2. 启动应用
  SHELLEXECUTEINFO sei = { sizeof(sei) };
  sei.fMask = SEE_MASK_NOCLOSEPROCESS;
  sei.lpVerb = L"open";
  sei.lpFile = Utf8ToWide(app.path).c_str();
  sei.nShow = SW_SHOWNORMAL;
  
  if (!ShellExecuteEx(&sei)) {
    spdlog::error("Failed to launch app: {}", app.path);
    return false;
  }
  
  // 3. 播放弹跳动画
  (*it)->Bounce();
  
  // 4. 发布事件
  EventSystem::Instance().Publish(EventType::DockAppLaunched, {
    {"id", id},
    {"path", app.path}
  });
  
  // 5. 延迟检测运行状态
  std::thread([this, id, processId = sei.hProcess]() {
    WaitForInputIdle(processId, 3000);
    UpdateRunningApps();
  }).detach();
  
  return true;
}
```

### 1.7 运行中应用检测

```cpp
void DockManager::UpdateRunningApps() {
  // 1. 枚举所有窗口
  std::vector<RunningApp> runningApps;
  
  EnumWindows([](HWND hwnd, LPARAM lParam) -> BOOL {
    auto* apps = reinterpret_cast<std::vector<RunningApp>*>(lParam);
    
    // 过滤：只要可见的、有标题的主窗口
    if (!IsWindowVisible(hwnd) || !IsMainWindow(hwnd)) {
      return TRUE;
    }
    
    // 获取进程信息
    DWORD processId;
    GetWindowThreadProcessId(hwnd, &processId);
    
    wchar_t exePath[MAX_PATH];
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, processId);
    if (hProcess) {
      DWORD size = MAX_PATH;
      QueryFullProcessImageName(hProcess, 0, exePath, &size);
      CloseHandle(hProcess);
      
      RunningApp app;
      app.hwnd = hwnd;
      app.processId = processId;
      app.exePath = WideToUtf8(exePath);
      app.title = GetWindowTitle(hwnd);
      app.icon = GetWindowIcon(hwnd);
      app.isMinimized = IsIconic(hwnd);
      
      apps->push_back(app);
    }
    
    return TRUE;
  }, reinterpret_cast<LPARAM>(&runningApps));
  
  // 2. 匹配 Dock 应用
  for (auto& item : m_items) {
    bool isRunning = false;
    
    for (const auto& runningApp : runningApps) {
      if (PathsMatch(item->GetApp().path, runningApp.exePath)) {
        isRunning = true;
        break;
      }
    }
    
    item->SetRunning(isRunning);
  }
  
  // 3. 触发重绘
  m_window->Invalidate();
}
```

### 1.8 前端接口（TypeScript）

```typescript
// frontend/src/api/dock.ts
export interface DockApp {
  id: string
  name: string
  path: string
  iconPath?: string
  position: number
  isPinned: boolean
}

export interface DockConfig {
  position: 'top' | 'bottom' | 'left' | 'right'
  autoHide: boolean
  iconSize: number
  theme: string
}

export const dockApi = {
  // 获取应用列表
  async getApps(): Promise<DockApp[]> {
    const result = await ipc.call('dock.getApps', {})
    return result.apps
  },
  
  // 添加应用
  async addApp(path: string): Promise<DockApp> {
    return await ipc.call('dock.addApp', { path })
  },
  
  // 移除应用
  async removeApp(id: string): Promise<void> {
    await ipc.call('dock.removeApp', { id })
  },
  
  // 启动应用
  async launchApp(id: string): Promise<void> {
    await ipc.call('dock.launchApp', { id })
  },
  
  // 更新配置
  async updateConfig(config: Partial<DockConfig>): Promise<void> {
    await ipc.call('dock.updateConfig', config)
  },
  
  // 监听事件
  onAppLaunched(callback: (app: DockApp) => void) {
    ipc.on('dock.appLaunched', callback)
  }
}
```

---

## 2. Wallpaper 模块

### 2.1 模块职责

- 静态壁纸显示
- 动态壁纸播放（视频/动画）
- 壁纸库管理
- 多显示器支持
- 定时自动切换

### 2.2 类设计

```cpp
// src/modules/wallpaper/WallpaperManager.h
class WallpaperManager {
public:
  WallpaperManager(WindowManager& windowMgr, RenderEngine& renderEngine);
  ~WallpaperManager();
  
  bool Initialize();
  void Shutdown();
  
  // 壁纸管理
  std::string AddWallpaper(const std::string& path, WallpaperType type);
  bool RemoveWallpaper(const std::string& id);
  nlohmann::json GetWallpapers() const;
  nlohmann::json GetWallpaper(const std::string& id) const;
  
  // 壁纸设置
  bool SetActiveWallpaper(const std::string& id);
  bool SetWallpaperForMonitor(const std::string& monitorId, const std::string& wallpaperId);
  
  // 自动切换
  void EnableAutoChange(int intervalSeconds);
  void DisableAutoChange();
  
  // 壁纸效果
  void SetFitMode(WallpaperFitMode mode);
  void SetBlur(float amount);  // 0.0 - 1.0
  
private:
  void CreateWallpaperWindows();
  void LoadWallpapersFromDatabase();
  std::string GenerateThumbnail(const std::string& sourcePath);
  
  std::map<std::string, std::unique_ptr<WallpaperWindow>> m_windows;
  std::map<std::string, Wallpaper> m_wallpapers;
  
  WindowManager& m_windowManager;
  RenderEngine& m_renderEngine;
  
  // 自动切换
  std::unique_ptr<std::thread> m_autoChangeThread;
  std::atomic<bool> m_autoChangeEnabled{false};
  int m_autoChangeInterval = 3600;
};
```

### 2.3 核心数据结构

```cpp
// 壁纸类型
enum class WallpaperType {
  Static,   // 静态图片
  Video,    // 视频
  Web       // 网页（可选，未来支持）
};

// 壁纸适配模式
enum class WallpaperFitMode {
  Fill,      // 填充（可能裁剪）
  Fit,       // 适应（保持比例）
  Stretch,   // 拉伸
  Center,    // 居中
  Tile       // 平铺
};

// 壁纸数据
struct Wallpaper {
  std::string id;
  std::string name;
  WallpaperType type;
  std::string filePath;          // 原始文件路径
  std::string thumbnailPath;     // 缩略图路径
  std::vector<std::string> tags; // 标签
  int64_t createdAt;
  int64_t fileSize;
  
  // 视频壁纸专属
  int width = 0;
  int height = 0;
  double duration = 0.0;
  double fps = 0.0;
  
  nlohmann::json ToJson() const;
  static Wallpaper FromJson(const nlohmann::json& json);
};
```

### 2.4 WallpaperWindow 设计

```cpp
// src/modules/wallpaper/WallpaperWindow.h
class WallpaperWindow : public BaseWindow {
public:
  WallpaperWindow(RenderEngine& renderEngine);
  
  bool Create(const MonitorInfo& monitor);
  bool SetWallpaper(const Wallpaper& wallpaper);
  void SetFitMode(WallpaperFitMode mode);
  void SetBlur(float amount);
  
  void Play();   // 视频壁纸
  void Pause();
  void Stop();
  
protected:
  LRESULT HandleMessage(UINT msg, WPARAM wParam, LPARAM lParam) override;
  void OnPaint();
  
private:
  void MakeDesktopWallpaper();  // 设置窗口为壁纸层级
  void RenderStatic();
  void RenderVideo();
  
  void LoadStaticWallpaper(const std::string& path);
  void LoadVideoWallpaper(const std::string& path);
  
  RenderEngine& m_renderEngine;
  Wallpaper m_wallpaper;
  WallpaperFitMode m_fitMode = WallpaperFitMode::Fill;
  float m_blurAmount = 0.0f;
  
  // 静态壁纸
  Microsoft::WRL::ComPtr<ID2D1Bitmap> m_staticBitmap;
  
  // 视频壁纸
  std::unique_ptr<VideoPlayer> m_videoPlayer;
  bool m_isPlaying = false;
};
```

### 2.5 VideoPlayer 设计

```cpp
// src/modules/wallpaper/VideoPlayer.h
class VideoPlayer {
public:
  VideoPlayer(ID3D11Device* device);
  ~VideoPlayer();
  
  bool Load(const std::string& path);
  void Unload();
  
  void Play();
  void Pause();
  void Stop();
  void Seek(double seconds);
  
  // 渲染
  void Update(double deltaTime);
  ID3D11ShaderResourceView* GetCurrentFrame();
  
  // 属性
  double GetDuration() const { return m_duration; }
  double GetCurrentTime() const { return m_currentTime; }
  bool IsPlaying() const { return m_isPlaying; }
  
private:
  void DecodeThread();
  bool DecodeNextFrame();
  
  ID3D11Device* m_device;
  ID3D11DeviceContext* m_context;
  
  // FFmpeg
  AVFormatContext* m_formatCtx = nullptr;
  AVCodecContext* m_codecCtx = nullptr;
  AVFrame* m_frame = nullptr;
  SwsContext* m_swsCtx = nullptr;
  int m_videoStreamIndex = -1;
  
  // 纹理
  Microsoft::WRL::ComPtr<ID3D11Texture2D> m_texture;
  Microsoft::WRL::ComPtr<ID3D11ShaderResourceView> m_textureSRV;
  
  // 状态
  std::atomic<bool> m_isPlaying{false};
  double m_duration = 0.0;
  double m_currentTime = 0.0;
  
  // 多线程
  std::unique_ptr<std::thread> m_decodeThread;
  std::queue<AVFrame*> m_frameQueue;
  std::mutex m_queueMutex;
  std::condition_variable m_queueCV;
};
```

### 2.6 壁纸窗口层级设置

```cpp
void WallpaperWindow::MakeDesktopWallpaper() {
  // 1. 找到 "Progman" 窗口
  HWND progman = FindWindow(L"Progman", nullptr);
  
  // 2. 发送消息创建 WorkerW 窗口
  SendMessageTimeout(progman, 0x052C, 0, 0, SMTO_NORMAL, 1000, nullptr);
  
  // 3. 找到 SHELLDLL_DefView 的父窗口（WorkerW）
  HWND workerw = nullptr;
  EnumWindows([](HWND hwnd, LPARAM lParam) -> BOOL {
    HWND shell = FindWindowEx(hwnd, nullptr, L"SHELLDLL_DefView", nullptr);
    if (shell != nullptr) {
      *reinterpret_cast<HWND*>(lParam) = FindWindowEx(nullptr, hwnd, L"WorkerW", nullptr);
      return FALSE;
    }
    return TRUE;
  }, reinterpret_cast<LPARAM>(&workerw));
  
  // 4. 将我们的窗口设置为 WorkerW 的子窗口
  if (workerw) {
    SetParent(m_hwnd, workerw);
  } else {
    // 降级方案：使用 HWND_BOTTOM
    SetWindowPos(m_hwnd, HWND_BOTTOM, 0, 0, 0, 0, 
      SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
  }
  
  // 5. 设置窗口样式
  SetWindowLong(m_hwnd, GWL_EXSTYLE, 
    GetWindowLong(m_hwnd, GWL_EXSTYLE) | WS_EX_NOACTIVATE);
}
```

### 2.7 多显示器支持

```cpp
void WallpaperManager::CreateWallpaperWindows() {
  auto monitors = m_windowManager.GetMonitors();
  
  for (const auto& monitor : monitors) {
    auto window = std::make_unique<WallpaperWindow>(m_renderEngine);
    
    if (!window->Create(monitor)) {
      spdlog::error("Failed to create wallpaper window for monitor {}", 
        monitor.name);
      continue;
    }
    
    // 从配置加载此显示器的壁纸
    std::string wallpaperId = GetWallpaperForMonitor(monitor.id);
    if (!wallpaperId.empty()) {
      auto it = m_wallpapers.find(wallpaperId);
      if (it != m_wallpapers.end()) {
        window->SetWallpaper(it->second);
      }
    }
    
    m_windows[monitor.id] = std::move(window);
  }
}

// 显示器信息结构
struct MonitorInfo {
  std::string id;        // 唯一标识（基于设备名生成）
  std::string name;      // 显示器名称
  RECT rect;             // 屏幕区域
  bool isPrimary;        // 是否主显示器
  int dpi;               // DPI
};
```

### 2.8 前端接口（TypeScript）

```typescript
// frontend/src/api/wallpaper.ts
export interface Wallpaper {
  id: string
  name: string
  type: 'static' | 'video' | 'web'
  filePath: string
  thumbnailPath: string
  tags: string[]
  createdAt: number
  fileSize: number
  width?: number
  height?: number
  duration?: number
}

export const wallpaperApi = {
  // 获取壁纸列表
  async getWallpapers(): Promise<Wallpaper[]> {
    return await ipc.call('wallpaper.getAll', {})
  },
  
  // 添加壁纸
  async addWallpaper(path: string): Promise<Wallpaper> {
    return await ipc.call('wallpaper.add', { path })
  },
  
  // 设置活动壁纸
  async setActive(id: string): Promise<void> {
    await ipc.call('wallpaper.setActive', { id })
  },
  
  // 为特定显示器设置壁纸
  async setForMonitor(monitorId: string, wallpaperId: string): Promise<void> {
    await ipc.call('wallpaper.setForMonitor', { monitorId, wallpaperId })
  },
  
  // 删除壁纸
  async remove(id: string): Promise<void> {
    await ipc.call('wallpaper.remove', { id })
  },
  
  // 自动切换
  async enableAutoChange(interval: number): Promise<void> {
    await ipc.call('wallpaper.enableAutoChange', { interval })
  }
}
```

---

## 3. Pet 模块

### 3.1 模块职责

- 桌宠模型加载与渲染
- 动画播放
- 物理模拟（重力、碰撞）
- 用户交互（拖拽、点击）
- AI 对话（可选）

### 3.2 类设计

```cpp
// src/modules/pet/PetManager.h
class PetManager {
public:
  PetManager(WindowManager& windowMgr, RenderEngine& renderEngine);
  ~PetManager();
  
  bool Initialize();
  void Shutdown();
  
  // 桌宠管理
  std::string SpawnPet(const std::string& modelName);
  bool DestroyPet(const std::string& id);
  nlohmann::json GetPets() const;
  
  // 桌宠控制
  bool SetPetPosition(const std::string& id, int x, int y);
  bool PlayAnimation(const std::string& id, const std::string& animName);
  bool SetPetScale(const std::string& id, float scale);
  
  // 模型库
  std::vector<PetModel> GetAvailableModels() const;
  bool LoadModel(const std::string& path);
  
private:
  void Update(float deltaTime);
  void LoadModelsFromDirectory(const std::string& dir);
  
  std::map<std::string, std::unique_ptr<PetInstance>> m_pets;
  std::map<std::string, PetModel> m_models;
  
  WindowManager& m_windowManager;
  RenderEngine& m_renderEngine;
  
  std::unique_ptr<std::thread> m_updateThread;
  std::atomic<bool> m_running{false};
};
```

### 3.3 核心数据结构

```cpp
// 桌宠模型定义
struct PetModel {
  std::string name;
  std::string description;
  std::string thumbnailPath;
  
  // 动画定义
  struct Animation {
    std::string name;
    std::vector<std::string> frames;  // 帧图片路径
    int fps;
    bool loop;
  };
  std::map<std::string, Animation> animations;
  
  // 默认行为
  std::string idleAnimation;
  std::string walkAnimation;
  std::string fallAnimation;
  
  // 物理属性
  float mass = 1.0f;
  float friction = 0.8f;
  
  nlohmann::json ToJson() const;
  static PetModel FromJson(const nlohmann::json& json);
};

// 桌宠实例
struct PetInstance {
  std::string id;
  std::string modelName;
  
  // 位置与状态
  float x, y;
  float velocityX = 0.0f;
  float velocityY = 0.0f;
  float scale = 1.0f;
  bool flipX = false;
  
  // 当前动画
  std::string currentAnimation;
  int currentFrame = 0;
  float frameTime = 0.0f;
  
  // 交互状态
  bool isDragging = false;
  bool isOnGround = false;
};
```

### 3.4 PetWindow 设计

```cpp
// src/modules/pet/PetWindow.h
class PetWindow : public BaseWindow {
public:
  PetWindow(RenderEngine& renderEngine, const PetModel& model);
  
  bool Create(int x, int y, float scale);
  void Update(float deltaTime);
  void SetPosition(int x, int y);
  void SetScale(float scale);
  void PlayAnimation(const std::string& name);
  
protected:
  LRESULT HandleMessage(UINT msg, WPARAM wParam, LPARAM lParam) override;
  void OnPaint();
  void OnMouseDown(int x, int y);
  void OnMouseMove(int x, int y);
  void OnMouseUp();
  
private:
  void LoadAnimationFrames(const std::string& animName);
  void UpdateAnimation(float deltaTime);
  void UpdatePhysics(float deltaTime);
  void CheckCollision();
  
  RenderEngine& m_renderEngine;
  PetModel m_model;
  PetInstance m_instance;
  
  // 动画帧缓存
  std::map<std::string, std::vector<Microsoft::WRL::ComPtr<ID2D1Bitmap>>> m_animationFrames;
  
  // 拖拽
  POINT m_dragOffset;
};
```

### 3.5 物理系统

```cpp
void PetWindow::UpdatePhysics(float deltaTime) {
  const float GRAVITY = 980.0f;  // 像素/秒²
  const float GROUND_Y = GetSystemMetrics(SM_CYSCREEN) - 100;  // 地面高度
  
  // 如果正在拖拽，不应用物理
  if (m_instance.isDragging) {
    m_instance.velocityX = 0.0f;
    m_instance.velocityY = 0.0f;
    m_instance.isOnGround = false;
    return;
  }
  
  // 应用重力
  if (!m_instance.isOnGround) {
    m_instance.velocityY += GRAVITY * deltaTime;
  }
  
  // 更新位置
  m_instance.x += m_instance.velocityX * deltaTime;
  m_instance.y += m_instance.velocityY * deltaTime;
  
  // 地面碰撞检测
  if (m_instance.y >= GROUND_Y) {
    m_instance.y = GROUND_Y;
    m_instance.velocityY = 0.0f;
    m_instance.isOnGround = true;
    
    // 摩擦力
    m_instance.velocityX *= m_model.friction;
    
    // 切换到闲置动画
    if (std::abs(m_instance.velocityX) < 10.0f) {
      PlayAnimation(m_model.idleAnimation);
    }
  } else {
    m_instance.isOnGround = false;
    PlayAnimation(m_model.fallAnimation);
  }
  
  // 屏幕边界碰撞
  int screenWidth = GetSystemMetrics(SM_CXSCREEN);
  if (m_instance.x < 0) {
    m_instance.x = 0;
    m_instance.velocityX = -m_instance.velocityX * 0.5f;
    m_instance.flipX = false;
  } else if (m_instance.x > screenWidth) {
    m_instance.x = screenWidth;
    m_instance.velocityX = -m_instance.velocityX * 0.5f;
    m_instance.flipX = true;
  }
  
  // 更新窗口位置
  SetWindowPos(m_hwnd, nullptr, 
    static_cast<int>(m_instance.x),
    static_cast<int>(m_instance.y),
    0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}
```

### 3.6 动画系统

```cpp
void PetWindow::UpdateAnimation(float deltaTime) {
  auto it = m_model.animations.find(m_instance.currentAnimation);
  if (it == m_model.animations.end()) return;
  
  const auto& anim = it->second;
  if (anim.frames.empty()) return;
  
  // 更新帧时间
  m_instance.frameTime += deltaTime;
  float frameDuration = 1.0f / anim.fps;
  
  if (m_instance.frameTime >= frameDuration) {
    m_instance.frameTime -= frameDuration;
    m_instance.currentFrame++;
    
    // 循环或停止
    if (m_instance.currentFrame >= anim.frames.size()) {
      if (anim.loop) {
        m_instance.currentFrame = 0;
      } else {
        m_instance.currentFrame = anim.frames.size() - 1;
        // 动画结束事件
        EventSystem::Instance().Publish(EventType::PetAnimationComplete, {
          {"petId", m_instance.id},
          {"animation", m_instance.currentAnimation}
        });
      }
    }
    
    // 触发重绘
    InvalidateRect(m_hwnd, nullptr, FALSE);
  }
}

void PetWindow::OnPaint() {
  auto* target = m_renderEngine.GetRenderTarget(m_hwnd);
  
  m_renderEngine.BeginDraw(target);
  m_renderEngine.Clear(target, D2D1::ColorF(0, 0.0f));  // 透明背景
  
  // 获取当前帧
  auto it = m_animationFrames.find(m_instance.currentAnimation);
  if (it != m_animationFrames.end() && 
      m_instance.currentFrame < it->second.size()) {
    auto& frameBitmap = it->second[m_instance.currentFrame];
    
    // 计算渲染矩形
    auto size = frameBitmap->GetSize();
    D2D1_RECT_F rect = D2D1::RectF(
      0, 0,
      size.width * m_instance.scale,
      size.height * m_instance.scale
    );
    
    // 翻转（镜像）
    if (m_instance.flipX) {
      target->d2dTarget->SetTransform(
        D2D1::Matrix3x2F::Scale(-1.0f, 1.0f, D2D1::Point2F(rect.right / 2, 0))
      );
    }
    
    // 绘制
    target->d2dTarget->DrawBitmap(
      frameBitmap.Get(),
      rect,
      1.0f,
      D2D1_BITMAP_INTERPOLATION_MODE_LINEAR
    );
    
    // 重置变换
    target->d2dTarget->SetTransform(D2D1::Matrix3x2F::Identity());
  }
  
  m_renderEngine.EndDraw(target);
}
```

### 3.7 交互处理

```cpp
void PetWindow::OnMouseDown(int x, int y) {
  // 开始拖拽
  m_instance.isDragging = true;
  m_dragOffset.x = x;
  m_dragOffset.y = y;
  
  SetCapture(m_hwnd);
  
  // 播放交互动画（如果有）
  if (m_model.animations.count("interact")) {
    PlayAnimation("interact");
  }
}

void PetWindow::OnMouseMove(int x, int y) {
  if (m_instance.isDragging) {
    // 计算新位置
    POINT cursor;
    GetCursorPos(&cursor);
    
    m_instance.x = cursor.x - m_dragOffset.x;
    m_instance.y = cursor.y - m_dragOffset.y;
    
    SetPosition(m_instance.x, m_instance.y);
  }
}

void PetWindow::OnMouseUp() {
  if (m_instance.isDragging) {
    m_instance.isDragging = false;
    ReleaseCapture();
    
    // 给一个初始速度（基于拖拽速度）
    // 可以通过记录最近几帧位置计算
    
    // 恢复默认动画
    PlayAnimation(m_model.idleAnimation);
  }
}
```

### 3.8 前端接口（TypeScript）

```typescript
// frontend/src/api/pet.ts
export interface PetModel {
  name: string
  description: string
  thumbnailPath: string
  animations: string[]
}

export interface Pet {
  id: string
  modelName: string
  x: number
  y: number
  scale: number
}

export const petApi = {
  // 获取可用模型
  async getModels(): Promise<PetModel[]> {
    return await ipc.call('pet.getModels', {})
  },
  
  // 生成桌宠
  async spawn(modelName: string): Promise<Pet> {
    return await ipc.call('pet.spawn', { modelName })
  },
  
  // 销毁桌宠
  async destroy(id: string): Promise<void> {
    await ipc.call('pet.destroy', { id })
  },
  
  // 播放动画
  async playAnimation(id: string, animationName: string): Promise<void> {
    await ipc.call('pet.playAnimation', { id, animationName })
  },
  
  // 设置缩放
  async setScale(id: string, scale: number): Promise<void> {
    await ipc.call('pet.setScale', { id, scale })
  }
}
```

---

## 模块间通信

### 事件流示例

```cpp
// 示例：壁纸切换影响 Dock 主题
EventSystem::Instance().Subscribe(
  EventType::WallpaperChanged,
  [](const Event& e) {
    std::string wallpaperId = e.data["id"];
    
    // 分析壁纸主色调
    auto dominantColor = AnalyzeWallpaperColor(wallpaperId);
    
    // 调整 Dock 主题以匹配
    auto& dockMgr = Application::Instance().GetDockManager();
    dockMgr.SetThemeColor(dominantColor);
  }
);
```

---

*模块设计将根据开发测试结果持续迭代优化*

